// Copyright 2021-present Eduate Pvt Ltd. All rights reserved.
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"adm-num/ent/admnumber"
	"adm-num/ent/mststudent"
	"adm-num/ent/predicate"
	"errors"
	"fmt"
	"time"
)

// AdmNumberWhereInput represents a where input for filtering AdmNumber queries.
type AdmNumberWhereInput struct {
	Predicates []predicate.AdmNumber  `json:"-"`
	Not        *AdmNumberWhereInput   `json:"not,omitempty"`
	Or         []*AdmNumberWhereInput `json:"or,omitempty"`
	And        []*AdmNumberWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "adm_start_no" field predicates.
	AdmStartNo             *string  `json:"admStartNo,omitempty"`
	AdmStartNoNEQ          *string  `json:"admStartNoNEQ,omitempty"`
	AdmStartNoIn           []string `json:"admStartNoIn,omitempty"`
	AdmStartNoNotIn        []string `json:"admStartNoNotIn,omitempty"`
	AdmStartNoGT           *string  `json:"admStartNoGT,omitempty"`
	AdmStartNoGTE          *string  `json:"admStartNoGTE,omitempty"`
	AdmStartNoLT           *string  `json:"admStartNoLT,omitempty"`
	AdmStartNoLTE          *string  `json:"admStartNoLTE,omitempty"`
	AdmStartNoContains     *string  `json:"admStartNoContains,omitempty"`
	AdmStartNoHasPrefix    *string  `json:"admStartNoHasPrefix,omitempty"`
	AdmStartNoHasSuffix    *string  `json:"admStartNoHasSuffix,omitempty"`
	AdmStartNoEqualFold    *string  `json:"admStartNoEqualFold,omitempty"`
	AdmStartNoContainsFold *string  `json:"admStartNoContainsFold,omitempty"`

	// "adm_current_no" field predicates.
	AdmCurrentNo             *string  `json:"admCurrentNo,omitempty"`
	AdmCurrentNoNEQ          *string  `json:"admCurrentNoNEQ,omitempty"`
	AdmCurrentNoIn           []string `json:"admCurrentNoIn,omitempty"`
	AdmCurrentNoNotIn        []string `json:"admCurrentNoNotIn,omitempty"`
	AdmCurrentNoGT           *string  `json:"admCurrentNoGT,omitempty"`
	AdmCurrentNoGTE          *string  `json:"admCurrentNoGTE,omitempty"`
	AdmCurrentNoLT           *string  `json:"admCurrentNoLT,omitempty"`
	AdmCurrentNoLTE          *string  `json:"admCurrentNoLTE,omitempty"`
	AdmCurrentNoContains     *string  `json:"admCurrentNoContains,omitempty"`
	AdmCurrentNoHasPrefix    *string  `json:"admCurrentNoHasPrefix,omitempty"`
	AdmCurrentNoHasSuffix    *string  `json:"admCurrentNoHasSuffix,omitempty"`
	AdmCurrentNoEqualFold    *string  `json:"admCurrentNoEqualFold,omitempty"`
	AdmCurrentNoContainsFold *string  `json:"admCurrentNoContainsFold,omitempty"`

	// "is_prefixed" field predicates.
	IsPrefixed    *bool `json:"isPrefixed,omitempty"`
	IsPrefixedNEQ *bool `json:"isPrefixedNEQ,omitempty"`

	// "prefix_str" field predicates.
	PrefixStr             *string  `json:"prefixStr,omitempty"`
	PrefixStrNEQ          *string  `json:"prefixStrNEQ,omitempty"`
	PrefixStrIn           []string `json:"prefixStrIn,omitempty"`
	PrefixStrNotIn        []string `json:"prefixStrNotIn,omitempty"`
	PrefixStrGT           *string  `json:"prefixStrGT,omitempty"`
	PrefixStrGTE          *string  `json:"prefixStrGTE,omitempty"`
	PrefixStrLT           *string  `json:"prefixStrLT,omitempty"`
	PrefixStrLTE          *string  `json:"prefixStrLTE,omitempty"`
	PrefixStrContains     *string  `json:"prefixStrContains,omitempty"`
	PrefixStrHasPrefix    *string  `json:"prefixStrHasPrefix,omitempty"`
	PrefixStrHasSuffix    *string  `json:"prefixStrHasSuffix,omitempty"`
	PrefixStrEqualFold    *string  `json:"prefixStrEqualFold,omitempty"`
	PrefixStrContainsFold *string  `json:"prefixStrContainsFold,omitempty"`

	// "suffix_str" field predicates.
	SuffixStr             *string  `json:"suffixStr,omitempty"`
	SuffixStrNEQ          *string  `json:"suffixStrNEQ,omitempty"`
	SuffixStrIn           []string `json:"suffixStrIn,omitempty"`
	SuffixStrNotIn        []string `json:"suffixStrNotIn,omitempty"`
	SuffixStrGT           *string  `json:"suffixStrGT,omitempty"`
	SuffixStrGTE          *string  `json:"suffixStrGTE,omitempty"`
	SuffixStrLT           *string  `json:"suffixStrLT,omitempty"`
	SuffixStrLTE          *string  `json:"suffixStrLTE,omitempty"`
	SuffixStrContains     *string  `json:"suffixStrContains,omitempty"`
	SuffixStrHasPrefix    *string  `json:"suffixStrHasPrefix,omitempty"`
	SuffixStrHasSuffix    *string  `json:"suffixStrHasSuffix,omitempty"`
	SuffixStrEqualFold    *string  `json:"suffixStrEqualFold,omitempty"`
	SuffixStrContainsFold *string  `json:"suffixStrContainsFold,omitempty"`

	// "separator" field predicates.
	Separator             *string  `json:"separator,omitempty"`
	SeparatorNEQ          *string  `json:"separatorNEQ,omitempty"`
	SeparatorIn           []string `json:"separatorIn,omitempty"`
	SeparatorNotIn        []string `json:"separatorNotIn,omitempty"`
	SeparatorGT           *string  `json:"separatorGT,omitempty"`
	SeparatorGTE          *string  `json:"separatorGTE,omitempty"`
	SeparatorLT           *string  `json:"separatorLT,omitempty"`
	SeparatorLTE          *string  `json:"separatorLTE,omitempty"`
	SeparatorContains     *string  `json:"separatorContains,omitempty"`
	SeparatorHasPrefix    *string  `json:"separatorHasPrefix,omitempty"`
	SeparatorHasSuffix    *string  `json:"separatorHasSuffix,omitempty"`
	SeparatorEqualFold    *string  `json:"separatorEqualFold,omitempty"`
	SeparatorContainsFold *string  `json:"separatorContainsFold,omitempty"`

	// "prefill_with_zero" field predicates.
	PrefillWithZero    *bool `json:"prefillWithZero,omitempty"`
	PrefillWithZeroNEQ *bool `json:"prefillWithZeroNEQ,omitempty"`

	// "prefill_width" field predicates.
	PrefillWidth      *int  `json:"prefillWidth,omitempty"`
	PrefillWidthNEQ   *int  `json:"prefillWidthNEQ,omitempty"`
	PrefillWidthIn    []int `json:"prefillWidthIn,omitempty"`
	PrefillWidthNotIn []int `json:"prefillWidthNotIn,omitempty"`
	PrefillWidthGT    *int  `json:"prefillWidthGT,omitempty"`
	PrefillWidthGTE   *int  `json:"prefillWidthGTE,omitempty"`
	PrefillWidthLT    *int  `json:"prefillWidthLT,omitempty"`
	PrefillWidthLTE   *int  `json:"prefillWidthLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AdmNumberWhereInput) AddPredicates(predicates ...predicate.AdmNumber) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AdmNumberWhereInput filter on the AdmNumberQuery builder.
func (i *AdmNumberWhereInput) Filter(q *AdmNumberQuery) (*AdmNumberQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAdmNumberWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAdmNumberWhereInput is returned in case the AdmNumberWhereInput is empty.
var ErrEmptyAdmNumberWhereInput = errors.New("ent: empty predicate AdmNumberWhereInput")

// P returns a predicate for filtering admnumbers.
// An error is returned if the input is empty or invalid.
func (i *AdmNumberWhereInput) P() (predicate.AdmNumber, error) {
	var predicates []predicate.AdmNumber
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, admnumber.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AdmNumber, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, admnumber.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AdmNumber, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, admnumber.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, admnumber.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, admnumber.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, admnumber.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, admnumber.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, admnumber.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, admnumber.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, admnumber.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, admnumber.IDLTE(*i.IDLTE))
	}
	if i.AdmStartNo != nil {
		predicates = append(predicates, admnumber.AdmStartNoEQ(*i.AdmStartNo))
	}
	if i.AdmStartNoNEQ != nil {
		predicates = append(predicates, admnumber.AdmStartNoNEQ(*i.AdmStartNoNEQ))
	}
	if len(i.AdmStartNoIn) > 0 {
		predicates = append(predicates, admnumber.AdmStartNoIn(i.AdmStartNoIn...))
	}
	if len(i.AdmStartNoNotIn) > 0 {
		predicates = append(predicates, admnumber.AdmStartNoNotIn(i.AdmStartNoNotIn...))
	}
	if i.AdmStartNoGT != nil {
		predicates = append(predicates, admnumber.AdmStartNoGT(*i.AdmStartNoGT))
	}
	if i.AdmStartNoGTE != nil {
		predicates = append(predicates, admnumber.AdmStartNoGTE(*i.AdmStartNoGTE))
	}
	if i.AdmStartNoLT != nil {
		predicates = append(predicates, admnumber.AdmStartNoLT(*i.AdmStartNoLT))
	}
	if i.AdmStartNoLTE != nil {
		predicates = append(predicates, admnumber.AdmStartNoLTE(*i.AdmStartNoLTE))
	}
	if i.AdmStartNoContains != nil {
		predicates = append(predicates, admnumber.AdmStartNoContains(*i.AdmStartNoContains))
	}
	if i.AdmStartNoHasPrefix != nil {
		predicates = append(predicates, admnumber.AdmStartNoHasPrefix(*i.AdmStartNoHasPrefix))
	}
	if i.AdmStartNoHasSuffix != nil {
		predicates = append(predicates, admnumber.AdmStartNoHasSuffix(*i.AdmStartNoHasSuffix))
	}
	if i.AdmStartNoEqualFold != nil {
		predicates = append(predicates, admnumber.AdmStartNoEqualFold(*i.AdmStartNoEqualFold))
	}
	if i.AdmStartNoContainsFold != nil {
		predicates = append(predicates, admnumber.AdmStartNoContainsFold(*i.AdmStartNoContainsFold))
	}
	if i.AdmCurrentNo != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoEQ(*i.AdmCurrentNo))
	}
	if i.AdmCurrentNoNEQ != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoNEQ(*i.AdmCurrentNoNEQ))
	}
	if len(i.AdmCurrentNoIn) > 0 {
		predicates = append(predicates, admnumber.AdmCurrentNoIn(i.AdmCurrentNoIn...))
	}
	if len(i.AdmCurrentNoNotIn) > 0 {
		predicates = append(predicates, admnumber.AdmCurrentNoNotIn(i.AdmCurrentNoNotIn...))
	}
	if i.AdmCurrentNoGT != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoGT(*i.AdmCurrentNoGT))
	}
	if i.AdmCurrentNoGTE != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoGTE(*i.AdmCurrentNoGTE))
	}
	if i.AdmCurrentNoLT != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoLT(*i.AdmCurrentNoLT))
	}
	if i.AdmCurrentNoLTE != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoLTE(*i.AdmCurrentNoLTE))
	}
	if i.AdmCurrentNoContains != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoContains(*i.AdmCurrentNoContains))
	}
	if i.AdmCurrentNoHasPrefix != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoHasPrefix(*i.AdmCurrentNoHasPrefix))
	}
	if i.AdmCurrentNoHasSuffix != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoHasSuffix(*i.AdmCurrentNoHasSuffix))
	}
	if i.AdmCurrentNoEqualFold != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoEqualFold(*i.AdmCurrentNoEqualFold))
	}
	if i.AdmCurrentNoContainsFold != nil {
		predicates = append(predicates, admnumber.AdmCurrentNoContainsFold(*i.AdmCurrentNoContainsFold))
	}
	if i.IsPrefixed != nil {
		predicates = append(predicates, admnumber.IsPrefixedEQ(*i.IsPrefixed))
	}
	if i.IsPrefixedNEQ != nil {
		predicates = append(predicates, admnumber.IsPrefixedNEQ(*i.IsPrefixedNEQ))
	}
	if i.PrefixStr != nil {
		predicates = append(predicates, admnumber.PrefixStrEQ(*i.PrefixStr))
	}
	if i.PrefixStrNEQ != nil {
		predicates = append(predicates, admnumber.PrefixStrNEQ(*i.PrefixStrNEQ))
	}
	if len(i.PrefixStrIn) > 0 {
		predicates = append(predicates, admnumber.PrefixStrIn(i.PrefixStrIn...))
	}
	if len(i.PrefixStrNotIn) > 0 {
		predicates = append(predicates, admnumber.PrefixStrNotIn(i.PrefixStrNotIn...))
	}
	if i.PrefixStrGT != nil {
		predicates = append(predicates, admnumber.PrefixStrGT(*i.PrefixStrGT))
	}
	if i.PrefixStrGTE != nil {
		predicates = append(predicates, admnumber.PrefixStrGTE(*i.PrefixStrGTE))
	}
	if i.PrefixStrLT != nil {
		predicates = append(predicates, admnumber.PrefixStrLT(*i.PrefixStrLT))
	}
	if i.PrefixStrLTE != nil {
		predicates = append(predicates, admnumber.PrefixStrLTE(*i.PrefixStrLTE))
	}
	if i.PrefixStrContains != nil {
		predicates = append(predicates, admnumber.PrefixStrContains(*i.PrefixStrContains))
	}
	if i.PrefixStrHasPrefix != nil {
		predicates = append(predicates, admnumber.PrefixStrHasPrefix(*i.PrefixStrHasPrefix))
	}
	if i.PrefixStrHasSuffix != nil {
		predicates = append(predicates, admnumber.PrefixStrHasSuffix(*i.PrefixStrHasSuffix))
	}
	if i.PrefixStrEqualFold != nil {
		predicates = append(predicates, admnumber.PrefixStrEqualFold(*i.PrefixStrEqualFold))
	}
	if i.PrefixStrContainsFold != nil {
		predicates = append(predicates, admnumber.PrefixStrContainsFold(*i.PrefixStrContainsFold))
	}
	if i.SuffixStr != nil {
		predicates = append(predicates, admnumber.SuffixStrEQ(*i.SuffixStr))
	}
	if i.SuffixStrNEQ != nil {
		predicates = append(predicates, admnumber.SuffixStrNEQ(*i.SuffixStrNEQ))
	}
	if len(i.SuffixStrIn) > 0 {
		predicates = append(predicates, admnumber.SuffixStrIn(i.SuffixStrIn...))
	}
	if len(i.SuffixStrNotIn) > 0 {
		predicates = append(predicates, admnumber.SuffixStrNotIn(i.SuffixStrNotIn...))
	}
	if i.SuffixStrGT != nil {
		predicates = append(predicates, admnumber.SuffixStrGT(*i.SuffixStrGT))
	}
	if i.SuffixStrGTE != nil {
		predicates = append(predicates, admnumber.SuffixStrGTE(*i.SuffixStrGTE))
	}
	if i.SuffixStrLT != nil {
		predicates = append(predicates, admnumber.SuffixStrLT(*i.SuffixStrLT))
	}
	if i.SuffixStrLTE != nil {
		predicates = append(predicates, admnumber.SuffixStrLTE(*i.SuffixStrLTE))
	}
	if i.SuffixStrContains != nil {
		predicates = append(predicates, admnumber.SuffixStrContains(*i.SuffixStrContains))
	}
	if i.SuffixStrHasPrefix != nil {
		predicates = append(predicates, admnumber.SuffixStrHasPrefix(*i.SuffixStrHasPrefix))
	}
	if i.SuffixStrHasSuffix != nil {
		predicates = append(predicates, admnumber.SuffixStrHasSuffix(*i.SuffixStrHasSuffix))
	}
	if i.SuffixStrEqualFold != nil {
		predicates = append(predicates, admnumber.SuffixStrEqualFold(*i.SuffixStrEqualFold))
	}
	if i.SuffixStrContainsFold != nil {
		predicates = append(predicates, admnumber.SuffixStrContainsFold(*i.SuffixStrContainsFold))
	}
	if i.Separator != nil {
		predicates = append(predicates, admnumber.SeparatorEQ(*i.Separator))
	}
	if i.SeparatorNEQ != nil {
		predicates = append(predicates, admnumber.SeparatorNEQ(*i.SeparatorNEQ))
	}
	if len(i.SeparatorIn) > 0 {
		predicates = append(predicates, admnumber.SeparatorIn(i.SeparatorIn...))
	}
	if len(i.SeparatorNotIn) > 0 {
		predicates = append(predicates, admnumber.SeparatorNotIn(i.SeparatorNotIn...))
	}
	if i.SeparatorGT != nil {
		predicates = append(predicates, admnumber.SeparatorGT(*i.SeparatorGT))
	}
	if i.SeparatorGTE != nil {
		predicates = append(predicates, admnumber.SeparatorGTE(*i.SeparatorGTE))
	}
	if i.SeparatorLT != nil {
		predicates = append(predicates, admnumber.SeparatorLT(*i.SeparatorLT))
	}
	if i.SeparatorLTE != nil {
		predicates = append(predicates, admnumber.SeparatorLTE(*i.SeparatorLTE))
	}
	if i.SeparatorContains != nil {
		predicates = append(predicates, admnumber.SeparatorContains(*i.SeparatorContains))
	}
	if i.SeparatorHasPrefix != nil {
		predicates = append(predicates, admnumber.SeparatorHasPrefix(*i.SeparatorHasPrefix))
	}
	if i.SeparatorHasSuffix != nil {
		predicates = append(predicates, admnumber.SeparatorHasSuffix(*i.SeparatorHasSuffix))
	}
	if i.SeparatorEqualFold != nil {
		predicates = append(predicates, admnumber.SeparatorEqualFold(*i.SeparatorEqualFold))
	}
	if i.SeparatorContainsFold != nil {
		predicates = append(predicates, admnumber.SeparatorContainsFold(*i.SeparatorContainsFold))
	}
	if i.PrefillWithZero != nil {
		predicates = append(predicates, admnumber.PrefillWithZeroEQ(*i.PrefillWithZero))
	}
	if i.PrefillWithZeroNEQ != nil {
		predicates = append(predicates, admnumber.PrefillWithZeroNEQ(*i.PrefillWithZeroNEQ))
	}
	if i.PrefillWidth != nil {
		predicates = append(predicates, admnumber.PrefillWidthEQ(*i.PrefillWidth))
	}
	if i.PrefillWidthNEQ != nil {
		predicates = append(predicates, admnumber.PrefillWidthNEQ(*i.PrefillWidthNEQ))
	}
	if len(i.PrefillWidthIn) > 0 {
		predicates = append(predicates, admnumber.PrefillWidthIn(i.PrefillWidthIn...))
	}
	if len(i.PrefillWidthNotIn) > 0 {
		predicates = append(predicates, admnumber.PrefillWidthNotIn(i.PrefillWidthNotIn...))
	}
	if i.PrefillWidthGT != nil {
		predicates = append(predicates, admnumber.PrefillWidthGT(*i.PrefillWidthGT))
	}
	if i.PrefillWidthGTE != nil {
		predicates = append(predicates, admnumber.PrefillWidthGTE(*i.PrefillWidthGTE))
	}
	if i.PrefillWidthLT != nil {
		predicates = append(predicates, admnumber.PrefillWidthLT(*i.PrefillWidthLT))
	}
	if i.PrefillWidthLTE != nil {
		predicates = append(predicates, admnumber.PrefillWidthLTE(*i.PrefillWidthLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAdmNumberWhereInput
	case 1:
		return predicates[0], nil
	default:
		return admnumber.And(predicates...), nil
	}
}

// MstStudentWhereInput represents a where input for filtering MstStudent queries.
type MstStudentWhereInput struct {
	Predicates []predicate.MstStudent  `json:"-"`
	Not        *MstStudentWhereInput   `json:"not,omitempty"`
	Or         []*MstStudentWhereInput `json:"or,omitempty"`
	And        []*MstStudentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "middle_name" field predicates.
	MiddleName             *string  `json:"middleName,omitempty"`
	MiddleNameNEQ          *string  `json:"middleNameNEQ,omitempty"`
	MiddleNameIn           []string `json:"middleNameIn,omitempty"`
	MiddleNameNotIn        []string `json:"middleNameNotIn,omitempty"`
	MiddleNameGT           *string  `json:"middleNameGT,omitempty"`
	MiddleNameGTE          *string  `json:"middleNameGTE,omitempty"`
	MiddleNameLT           *string  `json:"middleNameLT,omitempty"`
	MiddleNameLTE          *string  `json:"middleNameLTE,omitempty"`
	MiddleNameContains     *string  `json:"middleNameContains,omitempty"`
	MiddleNameHasPrefix    *string  `json:"middleNameHasPrefix,omitempty"`
	MiddleNameHasSuffix    *string  `json:"middleNameHasSuffix,omitempty"`
	MiddleNameEqualFold    *string  `json:"middleNameEqualFold,omitempty"`
	MiddleNameContainsFold *string  `json:"middleNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "std_studying" field predicates.
	StdStudying    *bool `json:"stdStudying,omitempty"`
	StdStudyingNEQ *bool `json:"stdStudyingNEQ,omitempty"`

	// "std_status" field predicates.
	StdStatus             *string  `json:"stdStatus,omitempty"`
	StdStatusNEQ          *string  `json:"stdStatusNEQ,omitempty"`
	StdStatusIn           []string `json:"stdStatusIn,omitempty"`
	StdStatusNotIn        []string `json:"stdStatusNotIn,omitempty"`
	StdStatusGT           *string  `json:"stdStatusGT,omitempty"`
	StdStatusGTE          *string  `json:"stdStatusGTE,omitempty"`
	StdStatusLT           *string  `json:"stdStatusLT,omitempty"`
	StdStatusLTE          *string  `json:"stdStatusLTE,omitempty"`
	StdStatusContains     *string  `json:"stdStatusContains,omitempty"`
	StdStatusHasPrefix    *string  `json:"stdStatusHasPrefix,omitempty"`
	StdStatusHasSuffix    *string  `json:"stdStatusHasSuffix,omitempty"`
	StdStatusEqualFold    *string  `json:"stdStatusEqualFold,omitempty"`
	StdStatusContainsFold *string  `json:"stdStatusContainsFold,omitempty"`

	// "std_sex" field predicates.
	StdSex             *string  `json:"stdSex,omitempty"`
	StdSexNEQ          *string  `json:"stdSexNEQ,omitempty"`
	StdSexIn           []string `json:"stdSexIn,omitempty"`
	StdSexNotIn        []string `json:"stdSexNotIn,omitempty"`
	StdSexGT           *string  `json:"stdSexGT,omitempty"`
	StdSexGTE          *string  `json:"stdSexGTE,omitempty"`
	StdSexLT           *string  `json:"stdSexLT,omitempty"`
	StdSexLTE          *string  `json:"stdSexLTE,omitempty"`
	StdSexContains     *string  `json:"stdSexContains,omitempty"`
	StdSexHasPrefix    *string  `json:"stdSexHasPrefix,omitempty"`
	StdSexHasSuffix    *string  `json:"stdSexHasSuffix,omitempty"`
	StdSexEqualFold    *string  `json:"stdSexEqualFold,omitempty"`
	StdSexContainsFold *string  `json:"stdSexContainsFold,omitempty"`

	// "std_reg_no" field predicates.
	StdRegNo             *string  `json:"stdRegNo,omitempty"`
	StdRegNoNEQ          *string  `json:"stdRegNoNEQ,omitempty"`
	StdRegNoIn           []string `json:"stdRegNoIn,omitempty"`
	StdRegNoNotIn        []string `json:"stdRegNoNotIn,omitempty"`
	StdRegNoGT           *string  `json:"stdRegNoGT,omitempty"`
	StdRegNoGTE          *string  `json:"stdRegNoGTE,omitempty"`
	StdRegNoLT           *string  `json:"stdRegNoLT,omitempty"`
	StdRegNoLTE          *string  `json:"stdRegNoLTE,omitempty"`
	StdRegNoContains     *string  `json:"stdRegNoContains,omitempty"`
	StdRegNoHasPrefix    *string  `json:"stdRegNoHasPrefix,omitempty"`
	StdRegNoHasSuffix    *string  `json:"stdRegNoHasSuffix,omitempty"`
	StdRegNoEqualFold    *string  `json:"stdRegNoEqualFold,omitempty"`
	StdRegNoContainsFold *string  `json:"stdRegNoContainsFold,omitempty"`

	// "std_adm_no" field predicates.
	StdAdmNo             *string  `json:"stdAdmNo,omitempty"`
	StdAdmNoNEQ          *string  `json:"stdAdmNoNEQ,omitempty"`
	StdAdmNoIn           []string `json:"stdAdmNoIn,omitempty"`
	StdAdmNoNotIn        []string `json:"stdAdmNoNotIn,omitempty"`
	StdAdmNoGT           *string  `json:"stdAdmNoGT,omitempty"`
	StdAdmNoGTE          *string  `json:"stdAdmNoGTE,omitempty"`
	StdAdmNoLT           *string  `json:"stdAdmNoLT,omitempty"`
	StdAdmNoLTE          *string  `json:"stdAdmNoLTE,omitempty"`
	StdAdmNoContains     *string  `json:"stdAdmNoContains,omitempty"`
	StdAdmNoHasPrefix    *string  `json:"stdAdmNoHasPrefix,omitempty"`
	StdAdmNoHasSuffix    *string  `json:"stdAdmNoHasSuffix,omitempty"`
	StdAdmNoEqualFold    *string  `json:"stdAdmNoEqualFold,omitempty"`
	StdAdmNoContainsFold *string  `json:"stdAdmNoContainsFold,omitempty"`

	// "std_doa" field predicates.
	StdDoa       *time.Time  `json:"stdDoa,omitempty"`
	StdDoaNEQ    *time.Time  `json:"stdDoaNEQ,omitempty"`
	StdDoaIn     []time.Time `json:"stdDoaIn,omitempty"`
	StdDoaNotIn  []time.Time `json:"stdDoaNotIn,omitempty"`
	StdDoaGT     *time.Time  `json:"stdDoaGT,omitempty"`
	StdDoaGTE    *time.Time  `json:"stdDoaGTE,omitempty"`
	StdDoaLT     *time.Time  `json:"stdDoaLT,omitempty"`
	StdDoaLTE    *time.Time  `json:"stdDoaLTE,omitempty"`
	StdDoaIsNil  bool        `json:"stdDoaIsNil,omitempty"`
	StdDoaNotNil bool        `json:"stdDoaNotNil,omitempty"`

	// "std_fresher" field predicates.
	StdFresher    *bool `json:"stdFresher,omitempty"`
	StdFresherNEQ *bool `json:"stdFresherNEQ,omitempty"`

	// "std_dob" field predicates.
	StdDob       *time.Time  `json:"stdDob,omitempty"`
	StdDobNEQ    *time.Time  `json:"stdDobNEQ,omitempty"`
	StdDobIn     []time.Time `json:"stdDobIn,omitempty"`
	StdDobNotIn  []time.Time `json:"stdDobNotIn,omitempty"`
	StdDobGT     *time.Time  `json:"stdDobGT,omitempty"`
	StdDobGTE    *time.Time  `json:"stdDobGTE,omitempty"`
	StdDobLT     *time.Time  `json:"stdDobLT,omitempty"`
	StdDobLTE    *time.Time  `json:"stdDobLTE,omitempty"`
	StdDobIsNil  bool        `json:"stdDobIsNil,omitempty"`
	StdDobNotNil bool        `json:"stdDobNotNil,omitempty"`

	// "std_email" field predicates.
	StdEmail             *string  `json:"stdEmail,omitempty"`
	StdEmailNEQ          *string  `json:"stdEmailNEQ,omitempty"`
	StdEmailIn           []string `json:"stdEmailIn,omitempty"`
	StdEmailNotIn        []string `json:"stdEmailNotIn,omitempty"`
	StdEmailGT           *string  `json:"stdEmailGT,omitempty"`
	StdEmailGTE          *string  `json:"stdEmailGTE,omitempty"`
	StdEmailLT           *string  `json:"stdEmailLT,omitempty"`
	StdEmailLTE          *string  `json:"stdEmailLTE,omitempty"`
	StdEmailContains     *string  `json:"stdEmailContains,omitempty"`
	StdEmailHasPrefix    *string  `json:"stdEmailHasPrefix,omitempty"`
	StdEmailHasSuffix    *string  `json:"stdEmailHasSuffix,omitempty"`
	StdEmailEqualFold    *string  `json:"stdEmailEqualFold,omitempty"`
	StdEmailContainsFold *string  `json:"stdEmailContainsFold,omitempty"`

	// "std_mobile" field predicates.
	StdMobile             *string  `json:"stdMobile,omitempty"`
	StdMobileNEQ          *string  `json:"stdMobileNEQ,omitempty"`
	StdMobileIn           []string `json:"stdMobileIn,omitempty"`
	StdMobileNotIn        []string `json:"stdMobileNotIn,omitempty"`
	StdMobileGT           *string  `json:"stdMobileGT,omitempty"`
	StdMobileGTE          *string  `json:"stdMobileGTE,omitempty"`
	StdMobileLT           *string  `json:"stdMobileLT,omitempty"`
	StdMobileLTE          *string  `json:"stdMobileLTE,omitempty"`
	StdMobileContains     *string  `json:"stdMobileContains,omitempty"`
	StdMobileHasPrefix    *string  `json:"stdMobileHasPrefix,omitempty"`
	StdMobileHasSuffix    *string  `json:"stdMobileHasSuffix,omitempty"`
	StdMobileEqualFold    *string  `json:"stdMobileEqualFold,omitempty"`
	StdMobileContainsFold *string  `json:"stdMobileContainsFold,omitempty"`

	// "std_father_name" field predicates.
	StdFatherName             *string  `json:"stdFatherName,omitempty"`
	StdFatherNameNEQ          *string  `json:"stdFatherNameNEQ,omitempty"`
	StdFatherNameIn           []string `json:"stdFatherNameIn,omitempty"`
	StdFatherNameNotIn        []string `json:"stdFatherNameNotIn,omitempty"`
	StdFatherNameGT           *string  `json:"stdFatherNameGT,omitempty"`
	StdFatherNameGTE          *string  `json:"stdFatherNameGTE,omitempty"`
	StdFatherNameLT           *string  `json:"stdFatherNameLT,omitempty"`
	StdFatherNameLTE          *string  `json:"stdFatherNameLTE,omitempty"`
	StdFatherNameContains     *string  `json:"stdFatherNameContains,omitempty"`
	StdFatherNameHasPrefix    *string  `json:"stdFatherNameHasPrefix,omitempty"`
	StdFatherNameHasSuffix    *string  `json:"stdFatherNameHasSuffix,omitempty"`
	StdFatherNameEqualFold    *string  `json:"stdFatherNameEqualFold,omitempty"`
	StdFatherNameContainsFold *string  `json:"stdFatherNameContainsFold,omitempty"`

	// "std_mother_name" field predicates.
	StdMotherName             *string  `json:"stdMotherName,omitempty"`
	StdMotherNameNEQ          *string  `json:"stdMotherNameNEQ,omitempty"`
	StdMotherNameIn           []string `json:"stdMotherNameIn,omitempty"`
	StdMotherNameNotIn        []string `json:"stdMotherNameNotIn,omitempty"`
	StdMotherNameGT           *string  `json:"stdMotherNameGT,omitempty"`
	StdMotherNameGTE          *string  `json:"stdMotherNameGTE,omitempty"`
	StdMotherNameLT           *string  `json:"stdMotherNameLT,omitempty"`
	StdMotherNameLTE          *string  `json:"stdMotherNameLTE,omitempty"`
	StdMotherNameContains     *string  `json:"stdMotherNameContains,omitempty"`
	StdMotherNameHasPrefix    *string  `json:"stdMotherNameHasPrefix,omitempty"`
	StdMotherNameHasSuffix    *string  `json:"stdMotherNameHasSuffix,omitempty"`
	StdMotherNameEqualFold    *string  `json:"stdMotherNameEqualFold,omitempty"`
	StdMotherNameContainsFold *string  `json:"stdMotherNameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MstStudentWhereInput) AddPredicates(predicates ...predicate.MstStudent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MstStudentWhereInput filter on the MstStudentQuery builder.
func (i *MstStudentWhereInput) Filter(q *MstStudentQuery) (*MstStudentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMstStudentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMstStudentWhereInput is returned in case the MstStudentWhereInput is empty.
var ErrEmptyMstStudentWhereInput = errors.New("ent: empty predicate MstStudentWhereInput")

// P returns a predicate for filtering mststudents.
// An error is returned if the input is empty or invalid.
func (i *MstStudentWhereInput) P() (predicate.MstStudent, error) {
	var predicates []predicate.MstStudent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mststudent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MstStudent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mststudent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MstStudent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mststudent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mststudent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mststudent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mststudent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mststudent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mststudent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mststudent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mststudent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mststudent.IDLTE(*i.IDLTE))
	}
	if i.FirstName != nil {
		predicates = append(predicates, mststudent.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, mststudent.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, mststudent.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, mststudent.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, mststudent.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, mststudent.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, mststudent.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, mststudent.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, mststudent.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, mststudent.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, mststudent.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, mststudent.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, mststudent.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.MiddleName != nil {
		predicates = append(predicates, mststudent.MiddleNameEQ(*i.MiddleName))
	}
	if i.MiddleNameNEQ != nil {
		predicates = append(predicates, mststudent.MiddleNameNEQ(*i.MiddleNameNEQ))
	}
	if len(i.MiddleNameIn) > 0 {
		predicates = append(predicates, mststudent.MiddleNameIn(i.MiddleNameIn...))
	}
	if len(i.MiddleNameNotIn) > 0 {
		predicates = append(predicates, mststudent.MiddleNameNotIn(i.MiddleNameNotIn...))
	}
	if i.MiddleNameGT != nil {
		predicates = append(predicates, mststudent.MiddleNameGT(*i.MiddleNameGT))
	}
	if i.MiddleNameGTE != nil {
		predicates = append(predicates, mststudent.MiddleNameGTE(*i.MiddleNameGTE))
	}
	if i.MiddleNameLT != nil {
		predicates = append(predicates, mststudent.MiddleNameLT(*i.MiddleNameLT))
	}
	if i.MiddleNameLTE != nil {
		predicates = append(predicates, mststudent.MiddleNameLTE(*i.MiddleNameLTE))
	}
	if i.MiddleNameContains != nil {
		predicates = append(predicates, mststudent.MiddleNameContains(*i.MiddleNameContains))
	}
	if i.MiddleNameHasPrefix != nil {
		predicates = append(predicates, mststudent.MiddleNameHasPrefix(*i.MiddleNameHasPrefix))
	}
	if i.MiddleNameHasSuffix != nil {
		predicates = append(predicates, mststudent.MiddleNameHasSuffix(*i.MiddleNameHasSuffix))
	}
	if i.MiddleNameEqualFold != nil {
		predicates = append(predicates, mststudent.MiddleNameEqualFold(*i.MiddleNameEqualFold))
	}
	if i.MiddleNameContainsFold != nil {
		predicates = append(predicates, mststudent.MiddleNameContainsFold(*i.MiddleNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, mststudent.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, mststudent.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, mststudent.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, mststudent.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, mststudent.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, mststudent.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, mststudent.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, mststudent.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, mststudent.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, mststudent.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, mststudent.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, mststudent.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, mststudent.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.StdStudying != nil {
		predicates = append(predicates, mststudent.StdStudyingEQ(*i.StdStudying))
	}
	if i.StdStudyingNEQ != nil {
		predicates = append(predicates, mststudent.StdStudyingNEQ(*i.StdStudyingNEQ))
	}
	if i.StdStatus != nil {
		predicates = append(predicates, mststudent.StdStatusEQ(*i.StdStatus))
	}
	if i.StdStatusNEQ != nil {
		predicates = append(predicates, mststudent.StdStatusNEQ(*i.StdStatusNEQ))
	}
	if len(i.StdStatusIn) > 0 {
		predicates = append(predicates, mststudent.StdStatusIn(i.StdStatusIn...))
	}
	if len(i.StdStatusNotIn) > 0 {
		predicates = append(predicates, mststudent.StdStatusNotIn(i.StdStatusNotIn...))
	}
	if i.StdStatusGT != nil {
		predicates = append(predicates, mststudent.StdStatusGT(*i.StdStatusGT))
	}
	if i.StdStatusGTE != nil {
		predicates = append(predicates, mststudent.StdStatusGTE(*i.StdStatusGTE))
	}
	if i.StdStatusLT != nil {
		predicates = append(predicates, mststudent.StdStatusLT(*i.StdStatusLT))
	}
	if i.StdStatusLTE != nil {
		predicates = append(predicates, mststudent.StdStatusLTE(*i.StdStatusLTE))
	}
	if i.StdStatusContains != nil {
		predicates = append(predicates, mststudent.StdStatusContains(*i.StdStatusContains))
	}
	if i.StdStatusHasPrefix != nil {
		predicates = append(predicates, mststudent.StdStatusHasPrefix(*i.StdStatusHasPrefix))
	}
	if i.StdStatusHasSuffix != nil {
		predicates = append(predicates, mststudent.StdStatusHasSuffix(*i.StdStatusHasSuffix))
	}
	if i.StdStatusEqualFold != nil {
		predicates = append(predicates, mststudent.StdStatusEqualFold(*i.StdStatusEqualFold))
	}
	if i.StdStatusContainsFold != nil {
		predicates = append(predicates, mststudent.StdStatusContainsFold(*i.StdStatusContainsFold))
	}
	if i.StdSex != nil {
		predicates = append(predicates, mststudent.StdSexEQ(*i.StdSex))
	}
	if i.StdSexNEQ != nil {
		predicates = append(predicates, mststudent.StdSexNEQ(*i.StdSexNEQ))
	}
	if len(i.StdSexIn) > 0 {
		predicates = append(predicates, mststudent.StdSexIn(i.StdSexIn...))
	}
	if len(i.StdSexNotIn) > 0 {
		predicates = append(predicates, mststudent.StdSexNotIn(i.StdSexNotIn...))
	}
	if i.StdSexGT != nil {
		predicates = append(predicates, mststudent.StdSexGT(*i.StdSexGT))
	}
	if i.StdSexGTE != nil {
		predicates = append(predicates, mststudent.StdSexGTE(*i.StdSexGTE))
	}
	if i.StdSexLT != nil {
		predicates = append(predicates, mststudent.StdSexLT(*i.StdSexLT))
	}
	if i.StdSexLTE != nil {
		predicates = append(predicates, mststudent.StdSexLTE(*i.StdSexLTE))
	}
	if i.StdSexContains != nil {
		predicates = append(predicates, mststudent.StdSexContains(*i.StdSexContains))
	}
	if i.StdSexHasPrefix != nil {
		predicates = append(predicates, mststudent.StdSexHasPrefix(*i.StdSexHasPrefix))
	}
	if i.StdSexHasSuffix != nil {
		predicates = append(predicates, mststudent.StdSexHasSuffix(*i.StdSexHasSuffix))
	}
	if i.StdSexEqualFold != nil {
		predicates = append(predicates, mststudent.StdSexEqualFold(*i.StdSexEqualFold))
	}
	if i.StdSexContainsFold != nil {
		predicates = append(predicates, mststudent.StdSexContainsFold(*i.StdSexContainsFold))
	}
	if i.StdRegNo != nil {
		predicates = append(predicates, mststudent.StdRegNoEQ(*i.StdRegNo))
	}
	if i.StdRegNoNEQ != nil {
		predicates = append(predicates, mststudent.StdRegNoNEQ(*i.StdRegNoNEQ))
	}
	if len(i.StdRegNoIn) > 0 {
		predicates = append(predicates, mststudent.StdRegNoIn(i.StdRegNoIn...))
	}
	if len(i.StdRegNoNotIn) > 0 {
		predicates = append(predicates, mststudent.StdRegNoNotIn(i.StdRegNoNotIn...))
	}
	if i.StdRegNoGT != nil {
		predicates = append(predicates, mststudent.StdRegNoGT(*i.StdRegNoGT))
	}
	if i.StdRegNoGTE != nil {
		predicates = append(predicates, mststudent.StdRegNoGTE(*i.StdRegNoGTE))
	}
	if i.StdRegNoLT != nil {
		predicates = append(predicates, mststudent.StdRegNoLT(*i.StdRegNoLT))
	}
	if i.StdRegNoLTE != nil {
		predicates = append(predicates, mststudent.StdRegNoLTE(*i.StdRegNoLTE))
	}
	if i.StdRegNoContains != nil {
		predicates = append(predicates, mststudent.StdRegNoContains(*i.StdRegNoContains))
	}
	if i.StdRegNoHasPrefix != nil {
		predicates = append(predicates, mststudent.StdRegNoHasPrefix(*i.StdRegNoHasPrefix))
	}
	if i.StdRegNoHasSuffix != nil {
		predicates = append(predicates, mststudent.StdRegNoHasSuffix(*i.StdRegNoHasSuffix))
	}
	if i.StdRegNoEqualFold != nil {
		predicates = append(predicates, mststudent.StdRegNoEqualFold(*i.StdRegNoEqualFold))
	}
	if i.StdRegNoContainsFold != nil {
		predicates = append(predicates, mststudent.StdRegNoContainsFold(*i.StdRegNoContainsFold))
	}
	if i.StdAdmNo != nil {
		predicates = append(predicates, mststudent.StdAdmNoEQ(*i.StdAdmNo))
	}
	if i.StdAdmNoNEQ != nil {
		predicates = append(predicates, mststudent.StdAdmNoNEQ(*i.StdAdmNoNEQ))
	}
	if len(i.StdAdmNoIn) > 0 {
		predicates = append(predicates, mststudent.StdAdmNoIn(i.StdAdmNoIn...))
	}
	if len(i.StdAdmNoNotIn) > 0 {
		predicates = append(predicates, mststudent.StdAdmNoNotIn(i.StdAdmNoNotIn...))
	}
	if i.StdAdmNoGT != nil {
		predicates = append(predicates, mststudent.StdAdmNoGT(*i.StdAdmNoGT))
	}
	if i.StdAdmNoGTE != nil {
		predicates = append(predicates, mststudent.StdAdmNoGTE(*i.StdAdmNoGTE))
	}
	if i.StdAdmNoLT != nil {
		predicates = append(predicates, mststudent.StdAdmNoLT(*i.StdAdmNoLT))
	}
	if i.StdAdmNoLTE != nil {
		predicates = append(predicates, mststudent.StdAdmNoLTE(*i.StdAdmNoLTE))
	}
	if i.StdAdmNoContains != nil {
		predicates = append(predicates, mststudent.StdAdmNoContains(*i.StdAdmNoContains))
	}
	if i.StdAdmNoHasPrefix != nil {
		predicates = append(predicates, mststudent.StdAdmNoHasPrefix(*i.StdAdmNoHasPrefix))
	}
	if i.StdAdmNoHasSuffix != nil {
		predicates = append(predicates, mststudent.StdAdmNoHasSuffix(*i.StdAdmNoHasSuffix))
	}
	if i.StdAdmNoEqualFold != nil {
		predicates = append(predicates, mststudent.StdAdmNoEqualFold(*i.StdAdmNoEqualFold))
	}
	if i.StdAdmNoContainsFold != nil {
		predicates = append(predicates, mststudent.StdAdmNoContainsFold(*i.StdAdmNoContainsFold))
	}
	if i.StdDoa != nil {
		predicates = append(predicates, mststudent.StdDoaEQ(*i.StdDoa))
	}
	if i.StdDoaNEQ != nil {
		predicates = append(predicates, mststudent.StdDoaNEQ(*i.StdDoaNEQ))
	}
	if len(i.StdDoaIn) > 0 {
		predicates = append(predicates, mststudent.StdDoaIn(i.StdDoaIn...))
	}
	if len(i.StdDoaNotIn) > 0 {
		predicates = append(predicates, mststudent.StdDoaNotIn(i.StdDoaNotIn...))
	}
	if i.StdDoaGT != nil {
		predicates = append(predicates, mststudent.StdDoaGT(*i.StdDoaGT))
	}
	if i.StdDoaGTE != nil {
		predicates = append(predicates, mststudent.StdDoaGTE(*i.StdDoaGTE))
	}
	if i.StdDoaLT != nil {
		predicates = append(predicates, mststudent.StdDoaLT(*i.StdDoaLT))
	}
	if i.StdDoaLTE != nil {
		predicates = append(predicates, mststudent.StdDoaLTE(*i.StdDoaLTE))
	}
	if i.StdDoaIsNil {
		predicates = append(predicates, mststudent.StdDoaIsNil())
	}
	if i.StdDoaNotNil {
		predicates = append(predicates, mststudent.StdDoaNotNil())
	}
	if i.StdFresher != nil {
		predicates = append(predicates, mststudent.StdFresherEQ(*i.StdFresher))
	}
	if i.StdFresherNEQ != nil {
		predicates = append(predicates, mststudent.StdFresherNEQ(*i.StdFresherNEQ))
	}
	if i.StdDob != nil {
		predicates = append(predicates, mststudent.StdDobEQ(*i.StdDob))
	}
	if i.StdDobNEQ != nil {
		predicates = append(predicates, mststudent.StdDobNEQ(*i.StdDobNEQ))
	}
	if len(i.StdDobIn) > 0 {
		predicates = append(predicates, mststudent.StdDobIn(i.StdDobIn...))
	}
	if len(i.StdDobNotIn) > 0 {
		predicates = append(predicates, mststudent.StdDobNotIn(i.StdDobNotIn...))
	}
	if i.StdDobGT != nil {
		predicates = append(predicates, mststudent.StdDobGT(*i.StdDobGT))
	}
	if i.StdDobGTE != nil {
		predicates = append(predicates, mststudent.StdDobGTE(*i.StdDobGTE))
	}
	if i.StdDobLT != nil {
		predicates = append(predicates, mststudent.StdDobLT(*i.StdDobLT))
	}
	if i.StdDobLTE != nil {
		predicates = append(predicates, mststudent.StdDobLTE(*i.StdDobLTE))
	}
	if i.StdDobIsNil {
		predicates = append(predicates, mststudent.StdDobIsNil())
	}
	if i.StdDobNotNil {
		predicates = append(predicates, mststudent.StdDobNotNil())
	}
	if i.StdEmail != nil {
		predicates = append(predicates, mststudent.StdEmailEQ(*i.StdEmail))
	}
	if i.StdEmailNEQ != nil {
		predicates = append(predicates, mststudent.StdEmailNEQ(*i.StdEmailNEQ))
	}
	if len(i.StdEmailIn) > 0 {
		predicates = append(predicates, mststudent.StdEmailIn(i.StdEmailIn...))
	}
	if len(i.StdEmailNotIn) > 0 {
		predicates = append(predicates, mststudent.StdEmailNotIn(i.StdEmailNotIn...))
	}
	if i.StdEmailGT != nil {
		predicates = append(predicates, mststudent.StdEmailGT(*i.StdEmailGT))
	}
	if i.StdEmailGTE != nil {
		predicates = append(predicates, mststudent.StdEmailGTE(*i.StdEmailGTE))
	}
	if i.StdEmailLT != nil {
		predicates = append(predicates, mststudent.StdEmailLT(*i.StdEmailLT))
	}
	if i.StdEmailLTE != nil {
		predicates = append(predicates, mststudent.StdEmailLTE(*i.StdEmailLTE))
	}
	if i.StdEmailContains != nil {
		predicates = append(predicates, mststudent.StdEmailContains(*i.StdEmailContains))
	}
	if i.StdEmailHasPrefix != nil {
		predicates = append(predicates, mststudent.StdEmailHasPrefix(*i.StdEmailHasPrefix))
	}
	if i.StdEmailHasSuffix != nil {
		predicates = append(predicates, mststudent.StdEmailHasSuffix(*i.StdEmailHasSuffix))
	}
	if i.StdEmailEqualFold != nil {
		predicates = append(predicates, mststudent.StdEmailEqualFold(*i.StdEmailEqualFold))
	}
	if i.StdEmailContainsFold != nil {
		predicates = append(predicates, mststudent.StdEmailContainsFold(*i.StdEmailContainsFold))
	}
	if i.StdMobile != nil {
		predicates = append(predicates, mststudent.StdMobileEQ(*i.StdMobile))
	}
	if i.StdMobileNEQ != nil {
		predicates = append(predicates, mststudent.StdMobileNEQ(*i.StdMobileNEQ))
	}
	if len(i.StdMobileIn) > 0 {
		predicates = append(predicates, mststudent.StdMobileIn(i.StdMobileIn...))
	}
	if len(i.StdMobileNotIn) > 0 {
		predicates = append(predicates, mststudent.StdMobileNotIn(i.StdMobileNotIn...))
	}
	if i.StdMobileGT != nil {
		predicates = append(predicates, mststudent.StdMobileGT(*i.StdMobileGT))
	}
	if i.StdMobileGTE != nil {
		predicates = append(predicates, mststudent.StdMobileGTE(*i.StdMobileGTE))
	}
	if i.StdMobileLT != nil {
		predicates = append(predicates, mststudent.StdMobileLT(*i.StdMobileLT))
	}
	if i.StdMobileLTE != nil {
		predicates = append(predicates, mststudent.StdMobileLTE(*i.StdMobileLTE))
	}
	if i.StdMobileContains != nil {
		predicates = append(predicates, mststudent.StdMobileContains(*i.StdMobileContains))
	}
	if i.StdMobileHasPrefix != nil {
		predicates = append(predicates, mststudent.StdMobileHasPrefix(*i.StdMobileHasPrefix))
	}
	if i.StdMobileHasSuffix != nil {
		predicates = append(predicates, mststudent.StdMobileHasSuffix(*i.StdMobileHasSuffix))
	}
	if i.StdMobileEqualFold != nil {
		predicates = append(predicates, mststudent.StdMobileEqualFold(*i.StdMobileEqualFold))
	}
	if i.StdMobileContainsFold != nil {
		predicates = append(predicates, mststudent.StdMobileContainsFold(*i.StdMobileContainsFold))
	}
	if i.StdFatherName != nil {
		predicates = append(predicates, mststudent.StdFatherNameEQ(*i.StdFatherName))
	}
	if i.StdFatherNameNEQ != nil {
		predicates = append(predicates, mststudent.StdFatherNameNEQ(*i.StdFatherNameNEQ))
	}
	if len(i.StdFatherNameIn) > 0 {
		predicates = append(predicates, mststudent.StdFatherNameIn(i.StdFatherNameIn...))
	}
	if len(i.StdFatherNameNotIn) > 0 {
		predicates = append(predicates, mststudent.StdFatherNameNotIn(i.StdFatherNameNotIn...))
	}
	if i.StdFatherNameGT != nil {
		predicates = append(predicates, mststudent.StdFatherNameGT(*i.StdFatherNameGT))
	}
	if i.StdFatherNameGTE != nil {
		predicates = append(predicates, mststudent.StdFatherNameGTE(*i.StdFatherNameGTE))
	}
	if i.StdFatherNameLT != nil {
		predicates = append(predicates, mststudent.StdFatherNameLT(*i.StdFatherNameLT))
	}
	if i.StdFatherNameLTE != nil {
		predicates = append(predicates, mststudent.StdFatherNameLTE(*i.StdFatherNameLTE))
	}
	if i.StdFatherNameContains != nil {
		predicates = append(predicates, mststudent.StdFatherNameContains(*i.StdFatherNameContains))
	}
	if i.StdFatherNameHasPrefix != nil {
		predicates = append(predicates, mststudent.StdFatherNameHasPrefix(*i.StdFatherNameHasPrefix))
	}
	if i.StdFatherNameHasSuffix != nil {
		predicates = append(predicates, mststudent.StdFatherNameHasSuffix(*i.StdFatherNameHasSuffix))
	}
	if i.StdFatherNameEqualFold != nil {
		predicates = append(predicates, mststudent.StdFatherNameEqualFold(*i.StdFatherNameEqualFold))
	}
	if i.StdFatherNameContainsFold != nil {
		predicates = append(predicates, mststudent.StdFatherNameContainsFold(*i.StdFatherNameContainsFold))
	}
	if i.StdMotherName != nil {
		predicates = append(predicates, mststudent.StdMotherNameEQ(*i.StdMotherName))
	}
	if i.StdMotherNameNEQ != nil {
		predicates = append(predicates, mststudent.StdMotherNameNEQ(*i.StdMotherNameNEQ))
	}
	if len(i.StdMotherNameIn) > 0 {
		predicates = append(predicates, mststudent.StdMotherNameIn(i.StdMotherNameIn...))
	}
	if len(i.StdMotherNameNotIn) > 0 {
		predicates = append(predicates, mststudent.StdMotherNameNotIn(i.StdMotherNameNotIn...))
	}
	if i.StdMotherNameGT != nil {
		predicates = append(predicates, mststudent.StdMotherNameGT(*i.StdMotherNameGT))
	}
	if i.StdMotherNameGTE != nil {
		predicates = append(predicates, mststudent.StdMotherNameGTE(*i.StdMotherNameGTE))
	}
	if i.StdMotherNameLT != nil {
		predicates = append(predicates, mststudent.StdMotherNameLT(*i.StdMotherNameLT))
	}
	if i.StdMotherNameLTE != nil {
		predicates = append(predicates, mststudent.StdMotherNameLTE(*i.StdMotherNameLTE))
	}
	if i.StdMotherNameContains != nil {
		predicates = append(predicates, mststudent.StdMotherNameContains(*i.StdMotherNameContains))
	}
	if i.StdMotherNameHasPrefix != nil {
		predicates = append(predicates, mststudent.StdMotherNameHasPrefix(*i.StdMotherNameHasPrefix))
	}
	if i.StdMotherNameHasSuffix != nil {
		predicates = append(predicates, mststudent.StdMotherNameHasSuffix(*i.StdMotherNameHasSuffix))
	}
	if i.StdMotherNameEqualFold != nil {
		predicates = append(predicates, mststudent.StdMotherNameEqualFold(*i.StdMotherNameEqualFold))
	}
	if i.StdMotherNameContainsFold != nil {
		predicates = append(predicates, mststudent.StdMotherNameContainsFold(*i.StdMotherNameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMstStudentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mststudent.And(predicates...), nil
	}
}
